{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"xqiang26","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"solutions/README","date":"2017-05-19T07:17:21.516Z","updated":"2016-08-10T03:02:03.026Z","comments":true,"path":"2017/05/19/solutions/README/","link":"","permalink":"http://yoursite.com/2017/05/19/solutions/README/","excerpt":"","text":"模拟原生效果实践 使用border-image实现类似物理1像素 [ios] Web App Icon与启动图片实践(1) [ios] Web App Icon与启动图片实践(2)","categories":[],"tags":[]},{"title":"","slug":"solutions/font-family","date":"2017-05-19T07:17:21.515Z","updated":"2016-08-10T03:02:03.026Z","comments":true,"path":"2017/05/19/solutions/font-family/","link":"","permalink":"http://yoursite.com/2017/05/19/solutions/font-family/","excerpt":"","text":"字体设置123body &#123; font-family: \"Helvetica Neue\", Helvetica, STHeiTi, sans-serif;&#125; iOS 4.0+ 使用英文字体 Helvetica Neue，之前的iOS版本降级使用 Helvetica。 中文字体设置为华文黑体STHeiTi。 需补充说明，华文黑体并不存在iOS的字体库中(http://support.apple.com/kb/HT5484?viewlocale=en_US)，但系统会自动将华文黑体STHeiTi兼容命中系统默认中文字体黑体-简或黑体-繁： 1234Heiti SC Light 黑体-简 细体Heiti SC Medium 黑体-简 中黑Heiti TC Light 黑体-繁 细体Heiti TC Medium 黑体-繁 中黑 原生Android下中文字体与英文字体都选择默认的无衬线字体。 4.0之前版本英文字体原生Android使用的是Droid Sans，中文字体原生Android会命中Droid Sans Fallback。 4.0+ 中英文字体都会使用原生Android新的Roboto字体。 其他第三方Android系统也一致选择默认的无衬线字体。 参考阅读 Droid, the default font for older versions of Android Roboto, the default font for newer versions of Android","categories":[],"tags":[]},{"title":"","slug":"solutions/project-structure","date":"2017-05-19T07:17:21.515Z","updated":"2016-08-10T03:02:03.027Z","comments":true,"path":"2017/05/19/solutions/project-structure/","link":"","permalink":"http://yoursite.com/2017/05/19/solutions/project-structure/","excerpt":"","text":"代码结构规范使用 Mobile Boilerplate","categories":[],"tags":[]},{"title":"","slug":"solutions/border-1px","date":"2017-05-19T07:17:21.509Z","updated":"2016-08-10T03:02:03.026Z","comments":true,"path":"2017/05/19/solutions/border-1px/","link":"","permalink":"http://yoursite.com/2017/05/19/solutions/border-1px/","excerpt":"","text":"使用border-image实现类似iOS7的1px底边iOS7已经发布有一段时间，扁平化设计风格有很多值得称赞的地方，其中有很多设计细节都是值得研究的。 首先，来看下面iOS设置的截图中的border： 从上面的截图可以看到iOS7的设计是非常精细的，border是一根非常细的线。这篇文章将说明如何使用border-image实现iOS7的border效果。 在看下面的内容之前，需要先了解devicePixelRatio和border-image，不熟悉的同学请自行脑补： 设备像素比devicePixelRatio简单介绍 CSS3 border-image详解、应用及jQuery插件 border属性实现效果我们在实现border时通常都是使用border属性，如下：12345.border-1px &#123; border-width: 1px 0; border-style: solid; border-color: #333;&#125; 显示效果对比： 上面这张图片可以看到，在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。 使用border-image属性实现物理1px通常手机端的页面设计稿都是放大一倍的，如：为适应iphone retina，设计稿会设计成640*960的分辨率，图片按照2倍大小切出来，在手机端看着就不会虚化，非常清晰。 同样，在使用border-image时，将border设计为物理1px，如下： 样式设置： 12345.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url(&quot;border.png&quot;) 2 0 stretch; border-image: url(&quot;border.png&quot;) 2 0 stretch;&#125; 显示效果对比： 这里在手机上的效果和iOS7已经非常接近了。 样例：http://maxzhang.github.com/examples/border1px/index.html Note: border.png也可以直接使用的base64替代1234.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url(&quot;data:image/png;base64,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&quot;) 2 0 stretch;&#125;","categories":[],"tags":[]},{"title":"","slug":"performance/README","date":"2017-05-19T07:13:22.362Z","updated":"2016-08-10T03:02:03.024Z","comments":true,"path":"2017/05/19/performance/README/","link":"","permalink":"http://yoursite.com/2017/05/19/performance/README/","excerpt":"","text":"高性能 Mobile Web 开发 高性能CSS3动画 CSS动画属性性能","categories":[],"tags":[]},{"title":"","slug":"performance/high-performance-css3-animation","date":"2017-05-19T07:13:22.342Z","updated":"2016-08-10T03:02:03.026Z","comments":true,"path":"2017/05/19/performance/high-performance-css3-animation/","link":"","permalink":"http://yoursite.com/2017/05/19/performance/high-performance-css3-animation/","excerpt":"","text":"高性能 CSS3 动画高性能移动Web相较PC的场景需要考虑的因素也相对更多更复杂，我们总结为以下几点： 流量、功耗与流畅度。在PC时代我们更多的是考虑体验上的流畅度，而在Mobile端本身丰富的场景下，需要额外关注对用户基站网络流量使用的情况，设备耗电量的情况。 关于流畅度，主要体现在前端动画中，在现有的前端动画体系中，通常有两种模式：JS动画与CSS3动画。JS动画是通过JS动态改写样式实现动画能力的一种方案，在PC端兼容低端浏览器中不失为一种推荐方案。而在移动端，我们选择性能更优浏览器原生实现方案：CSS3动画。 然而，CSS3动画在移动多终端设备场景下，相比PC会面对更多的性能问题，主要体现在动画的卡顿与闪烁。 目前对提升移动端CSS3动画体验的主要方法有几点： 尽可能多的利用硬件能力，如使用3D变形来开启GPU加速1234-webkit-transform: translate3d(0, 0, 0);-moz-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0); 如动画过程有闪烁（通常发生在动画开始的时候），可以尝试下面的Hack： 123456789-webkit-backface-visibility: hidden;-moz-backface-visibility: hidden;-ms-backface-visibility: hidden;backface-visibility: hidden;-webkit-perspective: 1000;-moz-perspective: 1000;-ms-perspective: 1000;perspective: 1000; 如下面一个元素通过translate3d右移500px的动画流畅度会明显优于使用left属性： 12345678910111213141516#ball-1 &#123; transition: -webkit-transform .5s ease; -webkit-transform: translate3d(0, 0, 0);&#125;#ball-1.slidein &#123; -webkit-transform: translate3d(500px, 0, 0);&#125;#ball-2 &#123; transition: left .5s ease; left: 0;&#125;#ball-2.slidein &#123; left: 500px;&#125; 注：3D变形会消耗更多的内存与功耗，应确实有性能问题时才去使用它，兼在权衡 尽可能少的使用box-shadows与gradientsbox-shadows与gradients往往都是页面的性能杀手，尤其是在一个元素同时都使用了它们，所以拥抱扁平化设计吧。 尽可能的让动画元素不在文档流中，以减少重排12position: fixed;position: absolute; 优化 DOM layout 性能我们从实例开始描述这个主题： 123456789var newWidth = aDiv.offsetWidth + 10;aDiv.style.width = newWidth + &apos;px&apos;;var newHeight = aDiv.offsetHeight + 10;aDiv.style.height = newHeight + &apos;px&apos;;var newWidth = aDiv.offsetWidth + 10;var newHeight = aDiv.offsetHeight + 10;aDiv.style.width = newWidth + &apos;px&apos;;aDiv.style.height = newHeight + &apos;px&apos;; 这是两段能力上完全等同的代码，显式的差异正如我们所见，只有执行顺序的区别。但真是如此吗？下面是加了说明注释的代码版本，很好的阐述了其中的进一步差异： 1234567891011// 触发两次 layoutvar newWidth = aDiv.offsetWidth + 10; // ReadaDiv.style.width = newWidth + 'px'; // Writevar newHeight = aDiv.offsetHeight + 10; // ReadaDiv.style.height = newHeight + 'px'; // Write// 只触发一次 layoutvar newWidth = aDiv.offsetWidth + 10; // Readvar newHeight = aDiv.offsetHeight + 10; // ReadaDiv.style.width = newWidth + 'px'; // WriteaDiv.style.height = newHeight + 'px'; // Write 从注释中可找到规律，连续的读取offsetWidth/Height属性与连续的设置width/height属性，相比分别读取设置单个属性可少触发一次layout。 从结论看似乎与执行队列有关，没错，这是浏览器的优化策略。所有可触发layout的操作都会被暂时放入 layout-queue 中，等到必须更新的时候，再计算整个队列中所有操作影响的结果，如此就可只进行一次的layout，从而提升性能。 关键一，可触发layout的操作，哪些操作下会layout的更新（也称为reflow或者relayout）？ 我们从浏览器的源码实现入手，以开源Webkit/Blink为例，对layout的更新，Webkit 主要通过 Document::updateLayout与 Document::updateLayoutIgnorePendingStylesheets两个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void Document::updateLayout()&#123; ASSERT(isMainThread()); FrameView* frameView = view(); if (frameView &amp;&amp; frameView-&gt;isInLayout()) &#123; ASSERT_NOT_REACHED(); return; &#125; if (Element* oe = ownerElement()) oe-&gt;document()-&gt;updateLayout(); updateStyleIfNeeded(); StackStats::LayoutCheckPoint layoutCheckPoint; if (frameView &amp;&amp; renderer() &amp;&amp; (frameView-&gt;layoutPending() || renderer()-&gt;needsLayout())) frameView-&gt;layout(); if (m_focusedNode &amp;&amp; !m_didPostCheckFocusedNodeTask) &#123; postTask(CheckFocusedNodeTask::create()); m_didPostCheckFocusedNodeTask = true; &#125;&#125;void Document::updateLayoutIgnorePendingStylesheets()&#123; bool oldIgnore = m_ignorePendingStylesheets; if (!haveStylesheetsLoaded()) &#123; m_ignorePendingStylesheets = true; HTMLElement* bodyElement = body(); if (bodyElement &amp;&amp; !bodyElement-&gt;renderer() &amp;&amp; m_pendingSheetLayout == NoLayoutWithPendingSheets) &#123; m_pendingSheetLayout = DidLayoutWithPendingSheets; styleResolverChanged(RecalcStyleImmediately); &#125; else if (m_hasNodesWithPlaceholderStyle) recalcStyle(Force); &#125; updateLayout(); m_ignorePendingStylesheets = oldIgnore;&#125; 从 updateLayoutIgnorePendingStylesheets 方法的内部实现可知，其也是对 updateLayout 方法的扩展，并且在现有的 layout 更新模式中，大部分场景都是调用 updateLayoutIgnorePendingStylesheets 来进行layout的更新。 搜索 Webkit 实现中调用 updateLayoutIgnorePendingStylesheets 方法的代码,得到以下可导致触发 layout 的操作： Element:clientHeight, clientLeft, clientTop, clientWidth, focus(), getBoundingClientRect(), getClientRects(), innerText, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth Frame, HTMLImageElement:height, width Range:getBoundingClientRect(), getClientRects() SVGLocatable:computeCTM(), getBBox() SVGTextContent:getCharNumAtPosition(), getComputedTextLength(), getEndPositionOfChar(), getExtentOfChar(), getNumberOfChars(), getRotationOfChar(), getStartPositionOfChar(), getSubStringLength(), selectSubString() SVGUse:instanceRoot window:getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY, webkitConvertPointFromNodeToPage(), webkitConvertPointFromPageToNode() 进一步深入Layout，那上文中必须更新的必要条件是什么？在 Stoyan Stefanov 的 Rendering: repaint, reflow/relayout, restyle 一文中已做比较详细的解答，可移步了解~ 相关阅读 Rendering: repaint, reflow/relayout, restyle How (not) to trigger a layout in WebKit","categories":[],"tags":[]},{"title":"","slug":"performance/css-property-animation-performance","date":"2017-05-19T07:13:22.341Z","updated":"2016-08-10T03:02:03.025Z","comments":true,"path":"2017/05/19/performance/css-property-animation-performance/","link":"","permalink":"http://yoursite.com/2017/05/19/performance/css-property-animation-performance/","excerpt":"","text":"CSS动画属性性能 CSS动画属性会触发整个页面的重排relayout、重绘repaint、重组recomposite Paint通常是其中最花费性能的，尽可能避免使用触发paint的CSS动画属性，这也是为什么我们推荐在CSS动画中使用webkit-transform: translateX(3em)的方案代替使用left: 3em，因为left会额外触发layout与paint，而webkit-transform只触发整个页面composite 1234567891011div &#123; -webkit-animation-duration: 5s; -webkit-animation-name: move; -webkit-animation-iteration-count: infinite; -webkit-animation-direction: alternate; width: 200px; height: 200px; margin: 100px; background-color: #808080; position: absolute;&#125; 12345678@-webkit-keyframes move&#123; from &#123; left: 100px; &#125; to &#123; left: 200px; &#125;&#125; 如下图使用left将持续触发页面重绘，表现为红色边框： 12345678@-webkit-keyframes move&#123; from &#123; -webkit-transform: translateX(100px); &#125; to &#123; -webkit-transform: translateX(200px); &#125;&#125; 如下图使用-webkit-transform页面只发生重组，表现为橙色边框： CSS属性在CSS动画中行为表 参考 #perfmatters: 60fps layout and rendering","categories":[],"tags":[]}]}